/*
 * PIOS trap handling definitions.
 *
 * Copyright (C) 1997 Massachusetts Institute of Technology
 * See section "MIT License" in the file LICENSES for licensing terms.
 *
 * Derived from the MIT Exokernel and JOS.
 * Adapted for PIOS by Bryan Ford at Yale University.
 */

#ifndef PIOS_INC_TRAP_H
#define PIOS_INC_TRAP_H

#include <inc/gcc.h>


// Trap numbers
// These are processor defined:
#define T_DIVIDE     0		// divide error
#define T_DEBUG      1		// debug exception
#define T_NMI        2		// non-maskable interrupt
#define T_BRKPT      3		// breakpoint
#define T_OFLOW      4		// overflow
#define T_BOUND      5		// bounds check
#define T_ILLOP      6		// illegal opcode
#define T_DEVICE     7		// device not available 
#define T_DBLFLT     8		// double fault
/* #define T_COPROC  9 */	// reserved (not generated by recent processors)
#define T_TSS       10		// invalid task switch segment
#define T_SEGNP     11		// segment not present
#define T_STACK     12		// stack exception
#define T_GPFLT     13		// general protection fault
#define T_PGFLT     14		// page fault
/* #define T_RES    15 */	// reserved
#define T_FPERR     16		// floating point error
#define T_ALIGN     17		// aligment check
#define T_MCHK      18		// machine check
#define T_SIMDERR   19		// SIMD floating point error

// These are arbitrarily chosen, but with care not to overlap
// processor defined exceptions or interrupt vectors.
#define T_SYSCALL   48		// system call
#define T_DEFAULT   500		// catchall

#define T_IRQ0		32	// This trap corresponds to IRQ0.

// Hardware IRQ numbers. We receive these as (T_IRQ0 + IRQ_WHATEVER)
#define IRQ_TIMER        0
#define IRQ_KBD          1
#define IRQ_SERIAL       4
#define IRQ_SPURIOUS     7
#define IRQ_IDE         14
#define IRQ_ERROR       19

#ifndef __ASSEMBLER__

#include <inc/types.h>


// General registers in the format pushed by PUSHA instruction.
// We use this instruction to push the general registers only for convenience:
// modern kernels generally avoid it and save the registers manually,
// because that's just as fast or faster and they get to choose
// exactly which registers to save and where.
typedef struct pushregs {
	uint32_t reg_edi;
	uint32_t reg_esi;
	uint32_t reg_ebp;
	uint32_t reg_oesp;		/* Useless */
	uint32_t reg_ebx;
	uint32_t reg_edx;
	uint32_t reg_ecx;
	uint32_t reg_eax;
} pushregs;


// This struct represents the format of the trap frames
// that get pushed on the kernel stack by the processor
// in conjunction with the interrupt/trap entry code in trapasm.S.
// All interrupts and traps use this same format,
// although not all fields are always used:
// e.g., the error code (tf_err) applies only to some traps,
// and the processor pushes tf_esp and tf_ss
// only when taking a trap from user mode (privilege level >0).
typedef struct trapframe {

	// registers and other info we push manually in trapasm.S
	pushregs tf_regs;
	uint16_t tf_es;
	uint16_t tf_padding1;
	uint16_t tf_ds;
	uint16_t tf_padding2;
	uint32_t tf_trapno;

	// format from here on determined by x86 hardware architecture
	uint32_t tf_err;
	uintptr_t tf_eip;
	uint16_t tf_cs;
	uint16_t tf_padding3;
	uint32_t tf_eflags;

	// rest included only when crossing rings, e.g., user to kernel
	uintptr_t tf_esp;
	uint16_t tf_ss;
	uint16_t tf_padding4;
} trapframe;

// size of trapframe pushed when called from user and kernel mode, respectively
#define trapframe_usize sizeof(trapframe)	// full trapframe struct
#define trapframe_ksize (sizeof(trapframe) - 8)	// no esp, ss, padding4


// Floating-point/MMX/XMM register save area format,
// in the layout defined by the processor's FXSAVE/FXRSTOR instructions.
typedef gcc_aligned(16) struct fxsave {
	uint16_t fcw;	// byte 0
	uint16_t	fsw;
	uint16_t	ftw;
	uint16_t	fop;
	uint32_t	fpu_ip;
	uint16_t	cs;
	uint16_t	reserved1;
	uint32_t	fpu_dp;			// byte 16
	uint16_t	ds;
	uint16_t	reserved2;
	uint32_t	mxcsr;
	uint32_t	mxcsr_mask;
	uint8_t		st_mm[8][16];		// byte 32: x87/MMX registers
	uint8_t		xmm[8][16];		// byte 160: XMM registers
	uint8_t		reserved3[11][16];	// byte 288: reserved area
	uint8_t		available[3][16];	// byte 464: available to OS
} fxsave;


#endif /* !__ASSEMBLER__ */

// Must equal 'sizeof(struct trapframe)'.
// A static_assert in kern/trap.c checks this.
#define SIZEOF_STRUCT_TRAPFRAME	0x44

#endif /* !PIOS_INC_TRAP_H */
